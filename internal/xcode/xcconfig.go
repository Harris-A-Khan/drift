// Package xcode provides utilities for Xcode configuration management.
package xcode

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/undrift/drift/internal/supabase"
)

// XcconfigGenerator generates Xcode configuration files.
type XcconfigGenerator struct {
	OutputPath     string
	BuildServerDir string
}

// NewXcconfigGenerator creates a new xcconfig generator.
func NewXcconfigGenerator(outputPath string) *XcconfigGenerator {
	return &XcconfigGenerator{
		OutputPath:     outputPath,
		BuildServerDir: filepath.Dir(outputPath),
	}
}

// XcconfigData holds the data for xcconfig generation.
type XcconfigData struct {
	GitBranch       string
	Environment     string
	SupabaseBranch  string
	ProjectRef      string
	APIURL          string
	AnonKey         string
	IsFallback      bool
	IsOverride      bool
	GeneratedAt     time.Time
}

// SupabaseBranchDisplay returns the branch name with fallback/override suffix.
func (d XcconfigData) SupabaseBranchDisplay() string {
	if d.IsFallback {
		return d.SupabaseBranch + " (fallback)"
	}
	if d.IsOverride {
		return d.SupabaseBranch + " (override)"
	}
	return d.SupabaseBranch
}

// EscapedURL returns the URL with $() escape for Xcode xcconfig parsing.
func (d XcconfigData) EscapedURL() string {
	// Xcode xcconfig needs // escaped as /$()/ to avoid comment parsing issues
	return strings.Replace(d.APIURL, "//", "/$()/", 1)
}

const xcconfigTemplate = `// Config.xcconfig - SECRETS FILE (gitignored)
// Auto-generated by drift
//
// Environment: {{.Environment}}
// Git Branch: {{.GitBranch}}
// Supabase Branch: {{.SupabaseBranch}}
// Project Ref: {{.ProjectRef}}
// Using Fallback: {{.IsFallback}}
// Using Override: {{.IsOverride}}
// Generated: {{.GeneratedAt.Format "Mon Jan  2 15:04:05 MST 2006"}}
//
// DO NOT COMMIT THIS FILE

SUPABASE_URL = {{.EscapedURL}}
SUPABASE_ANON_KEY = {{.AnonKey}}

// Branch info for environment badge (shown in non-production builds)
GIT_BRANCH_NAME = {{.GitBranch}}
SUPABASE_BRANCH_NAME = {{.SupabaseBranchDisplay}}
DRIFT_ENVIRONMENT = {{.Environment}}
`

// Generate generates the Config.xcconfig file.
func (g *XcconfigGenerator) Generate(data XcconfigData) error {
	tmpl, err := template.New("xcconfig").Parse(xcconfigTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Ensure directory exists
	dir := filepath.Dir(g.OutputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Create output file
	f, err := os.Create(g.OutputPath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	// Execute template
	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to write xcconfig: %w", err)
	}

	return nil
}

// GenerateFromBranchInfo generates xcconfig from Supabase branch info.
func (g *XcconfigGenerator) GenerateFromBranchInfo(info *supabase.BranchInfo, anonKey string) error {
	data := XcconfigData{
		GitBranch:      info.GitBranch,
		Environment:    string(info.Environment),
		SupabaseBranch: info.SupabaseBranch.Name,
		ProjectRef:     info.ProjectRef,
		APIURL:         info.APIURL,
		AnonKey:        anonKey,
		IsFallback:     info.IsFallback,
		IsOverride:     info.IsOverride,
		GeneratedAt:    time.Now(),
	}

	return g.Generate(data)
}

// GenerateBuildServerJSON generates the buildServer.json for sourcekit-lsp.
func (g *XcconfigGenerator) GenerateBuildServerJSON(xcodeProjectPath, scheme string) error {
	buildServerPath := filepath.Join(g.BuildServerDir, "buildServer.json")

	// Find the .xcodeproj or .xcworkspace
	projectFile := xcodeProjectPath
	if projectFile == "" {
		// Try to find it
		matches, _ := filepath.Glob(filepath.Join(g.BuildServerDir, "*.xcworkspace"))
		if len(matches) > 0 {
			projectFile = matches[0]
		} else {
			matches, _ = filepath.Glob(filepath.Join(g.BuildServerDir, "*.xcodeproj"))
			if len(matches) > 0 {
				projectFile = matches[0]
			}
		}
	}

	if projectFile == "" {
		return fmt.Errorf("no Xcode project found")
	}

	content := fmt.Sprintf(`{
  "name": "xcode build server",
  "version": "0.2",
  "bspVersion": "2.0",
  "languages": ["swift", "objective-c", "objective-cpp", "c", "cpp"],
  "argv": [
    "/Applications/Xcode.app/Contents/Developer/usr/bin/xcode-build-server"
  ],
  "build_root": "%s",
  "workspace": "%s",
  "scheme": "%s"
}
`, g.BuildServerDir, projectFile, scheme)

	return os.WriteFile(buildServerPath, []byte(content), 0644)
}

// ReadXcconfig reads an existing xcconfig file and returns its values as a map.
func ReadXcconfig(path string) (map[string]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	values := make(map[string]string)
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		
		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}

		// Parse KEY = VALUE
		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			values[key] = value
		}
	}

	return values, nil
}

// GetCurrentEnvironment reads the current environment from the xcconfig.
func GetCurrentEnvironment(xcconfigPath string) (string, error) {
	// First try to read from key-value pairs
	values, err := ReadXcconfig(xcconfigPath)
	if err != nil {
		return "", err
	}

	if env, ok := values["DRIFT_ENVIRONMENT"]; ok {
		return env, nil
	}

	// Fallback: try to parse from comment header
	data, err := os.ReadFile(xcconfigPath)
	if err != nil {
		return "", err
	}

	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "// Environment:") {
			env := strings.TrimSpace(strings.TrimPrefix(line, "// Environment:"))
			if env != "" {
				return env, nil
			}
		}
	}

	return "", fmt.Errorf("environment not found in %s", xcconfigPath)
}

// XcconfigExists checks if the xcconfig file exists.
func XcconfigExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

