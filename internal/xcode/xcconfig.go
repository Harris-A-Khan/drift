// Package xcode provides utilities for Xcode configuration management.
package xcode

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/undrift/drift/internal/supabase"
)

// XcconfigGenerator generates Xcode configuration files.
type XcconfigGenerator struct {
	OutputPath     string
	BuildServerDir string
}

// NewXcconfigGenerator creates a new xcconfig generator.
func NewXcconfigGenerator(outputPath string) *XcconfigGenerator {
	return &XcconfigGenerator{
		OutputPath:     outputPath,
		BuildServerDir: filepath.Dir(outputPath),
	}
}

// XcconfigData holds the data for xcconfig generation.
type XcconfigData struct {
	GitBranch       string
	Environment     string
	SupabaseBranch  string
	ProjectRef      string
	APIURL          string
	AnonKey         string
	IsFallback      bool
	IsOverride      bool
	GeneratedAt     time.Time
}

// SupabaseBranchDisplay returns the branch name with fallback/override suffix.
func (d XcconfigData) SupabaseBranchDisplay() string {
	if d.IsFallback {
		return d.SupabaseBranch + " (fallback)"
	}
	if d.IsOverride {
		return d.SupabaseBranch + " (override)"
	}
	return d.SupabaseBranch
}

// EscapedURL returns the URL with $() escape for Xcode xcconfig parsing.
func (d XcconfigData) EscapedURL() string {
	// Xcode xcconfig needs // escaped as /$()/ to avoid comment parsing issues
	return strings.Replace(d.APIURL, "//", "/$()/", 1)
}

// Section markers for preserving user variables
const (
	XcconfigDriftStart = "// === DRIFT MANAGED START ==="
	XcconfigDriftEnd   = "// === DRIFT MANAGED END ==="
)

const xcconfigTemplate = `// Config.xcconfig - SECRETS FILE (gitignored)
// Auto-generated by drift - DO NOT COMMIT THIS FILE
//
// Environment: {{.Environment}}
// Git Branch: {{.GitBranch}}
// Supabase Branch: {{.SupabaseBranch}}
// Project Ref: {{.ProjectRef}}
// Using Fallback: {{.IsFallback}}
// Using Override: {{.IsOverride}}
// Generated: {{.GeneratedAt.Format "Mon Jan  2 15:04:05 MST 2006"}}

// === DRIFT MANAGED START ===
// Variables below are managed by drift. Do not edit manually.
// Run 'drift env setup' to update these values.

SUPABASE_URL = {{.EscapedURL}}
SUPABASE_ANON_KEY = {{.AnonKey}}

// Branch info for environment badge (shown in non-production builds)
GIT_BRANCH_NAME = {{.GitBranch}}
SUPABASE_BRANCH_NAME = {{.SupabaseBranchDisplay}}
DRIFT_ENVIRONMENT = {{.Environment}}

// === DRIFT MANAGED END ===

// =============================================================================
// CUSTOM VARIABLES (add your own variables below - they will be preserved)
// =============================================================================
`

// Generate generates the Config.xcconfig file, preserving user-added variables.
func (g *XcconfigGenerator) Generate(data XcconfigData) error {
	tmpl, err := template.New("xcconfig").Parse(xcconfigTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Generate new drift-managed content
	var driftContent strings.Builder
	if err := tmpl.Execute(&driftContent, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Check if file exists and has user content to preserve
	userContent := ""
	if existingData, err := os.ReadFile(g.OutputPath); err == nil {
		userContent = extractXcconfigUserContent(string(existingData))
	}

	// Combine drift content with user content
	finalContent := driftContent.String()
	if userContent != "" {
		finalContent = strings.TrimSuffix(finalContent, "\n") + "\n" + userContent
	}

	// Ensure directory exists
	dir := filepath.Dir(g.OutputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write final content
	if err := os.WriteFile(g.OutputPath, []byte(finalContent), 0644); err != nil {
		return fmt.Errorf("failed to write xcconfig: %w", err)
	}

	return nil
}

// extractXcconfigUserContent extracts user-added content from an existing xcconfig file.
func extractXcconfigUserContent(content string) string {
	// Check if file has drift markers
	endIdx := strings.Index(content, XcconfigDriftEnd)
	if endIdx != -1 {
		// File has markers - extract everything after the end marker
		afterEnd := content[endIdx+len(XcconfigDriftEnd):]
		// Skip the "CUSTOM VARIABLES" header if it exists (we'll add a fresh one)
		if idx := strings.Index(afterEnd, "// CUSTOM VARIABLES"); idx != -1 {
			afterEnd = afterEnd[idx:]
			// Find the end of the header section (after the === line)
			lines := strings.SplitN(afterEnd, "\n", 4)
			if len(lines) >= 4 {
				afterEnd = strings.Join(lines[3:], "\n")
			}
		}
		// Clean up and return non-empty user content
		afterEnd = strings.TrimSpace(afterEnd)
		if afterEnd != "" {
			return "\n" + afterEnd + "\n"
		}
		return ""
	}

	// Legacy file without markers - try to extract non-drift variables
	driftVars := map[string]bool{
		"SUPABASE_URL":         true,
		"SUPABASE_ANON_KEY":    true,
		"GIT_BRANCH_NAME":      true,
		"SUPABASE_BRANCH_NAME": true,
		"DRIFT_ENVIRONMENT":    true,
	}

	var userLines []string
	inUserSection := false
	lines := strings.Split(content, "\n")

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip empty lines and comments at the start
		if trimmed == "" || strings.HasPrefix(trimmed, "//") {
			if inUserSection {
				userLines = append(userLines, line)
			}
			continue
		}

		// Check if this is a variable line
		if strings.Contains(trimmed, "=") {
			parts := strings.SplitN(trimmed, "=", 2)
			varName := strings.TrimSpace(parts[0])

			// Check if this is a drift-managed variable
			if driftVars[varName] {
				continue
			}

			// This is a user variable
			inUserSection = true
			userLines = append(userLines, line)
		} else if inUserSection {
			userLines = append(userLines, line)
		}
	}

	if len(userLines) > 0 {
		result := strings.Join(userLines, "\n")
		result = strings.TrimSpace(result)
		if result != "" {
			return "\n" + result + "\n"
		}
	}

	return ""
}

// GenerateFromBranchInfo generates xcconfig from Supabase branch info.
func (g *XcconfigGenerator) GenerateFromBranchInfo(info *supabase.BranchInfo, anonKey string) error {
	data := XcconfigData{
		GitBranch:      info.GitBranch,
		Environment:    string(info.Environment),
		SupabaseBranch: info.SupabaseBranch.Name,
		ProjectRef:     info.ProjectRef,
		APIURL:         info.APIURL,
		AnonKey:        anonKey,
		IsFallback:     info.IsFallback,
		IsOverride:     info.IsOverride,
		GeneratedAt:    time.Now(),
	}

	return g.Generate(data)
}

// GenerateBuildServerJSON generates the buildServer.json for sourcekit-lsp.
func (g *XcconfigGenerator) GenerateBuildServerJSON(xcodeProjectPath, scheme string) error {
	buildServerPath := filepath.Join(g.BuildServerDir, "buildServer.json")

	// Find the .xcodeproj or .xcworkspace
	projectFile := xcodeProjectPath
	if projectFile == "" {
		// Try to find it
		matches, _ := filepath.Glob(filepath.Join(g.BuildServerDir, "*.xcworkspace"))
		if len(matches) > 0 {
			projectFile = matches[0]
		} else {
			matches, _ = filepath.Glob(filepath.Join(g.BuildServerDir, "*.xcodeproj"))
			if len(matches) > 0 {
				projectFile = matches[0]
			}
		}
	}

	if projectFile == "" {
		return fmt.Errorf("no Xcode project found")
	}

	content := fmt.Sprintf(`{
  "name": "xcode build server",
  "version": "0.2",
  "bspVersion": "2.0",
  "languages": ["swift", "objective-c", "objective-cpp", "c", "cpp"],
  "argv": [
    "/Applications/Xcode.app/Contents/Developer/usr/bin/xcode-build-server"
  ],
  "build_root": "%s",
  "workspace": "%s",
  "scheme": "%s"
}
`, g.BuildServerDir, projectFile, scheme)

	return os.WriteFile(buildServerPath, []byte(content), 0644)
}

// ReadXcconfig reads an existing xcconfig file and returns its values as a map.
func ReadXcconfig(path string) (map[string]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	values := make(map[string]string)
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		
		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}

		// Parse KEY = VALUE
		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			values[key] = value
		}
	}

	return values, nil
}

// GetCurrentEnvironment reads the current environment from the xcconfig.
func GetCurrentEnvironment(xcconfigPath string) (string, error) {
	// First try to read from key-value pairs
	values, err := ReadXcconfig(xcconfigPath)
	if err != nil {
		return "", err
	}

	if env, ok := values["DRIFT_ENVIRONMENT"]; ok {
		return env, nil
	}

	// Fallback: try to parse from comment header
	data, err := os.ReadFile(xcconfigPath)
	if err != nil {
		return "", err
	}

	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "// Environment:") {
			env := strings.TrimSpace(strings.TrimPrefix(line, "// Environment:"))
			if env != "" {
				return env, nil
			}
		}
	}

	return "", fmt.Errorf("environment not found in %s", xcconfigPath)
}

// XcconfigExists checks if the xcconfig file exists.
func XcconfigExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

