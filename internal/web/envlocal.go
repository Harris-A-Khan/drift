// Package web provides utilities for web project configuration management.
package web

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/undrift/drift/internal/supabase"
)

// EnvLocalGenerator generates .env.local files for web projects.
type EnvLocalGenerator struct {
	OutputPath string
}

// NewEnvLocalGenerator creates a new .env.local generator.
func NewEnvLocalGenerator(outputPath string) *EnvLocalGenerator {
	return &EnvLocalGenerator{
		OutputPath: outputPath,
	}
}

// EnvLocalData holds the data for .env.local generation.
type EnvLocalData struct {
	GitBranch      string
	Environment    string
	SupabaseBranch string
	ProjectRef     string
	APIURL         string
	AnonKey        string
	IsFallback     bool
	IsOverride     bool
	GeneratedAt    time.Time
}

// SupabaseBranchDisplay returns the branch name with fallback/override suffix.
func (d EnvLocalData) SupabaseBranchDisplay() string {
	if d.IsFallback {
		return d.SupabaseBranch + " (fallback)"
	}
	if d.IsOverride {
		return d.SupabaseBranch + " (override)"
	}
	return d.SupabaseBranch
}

const envLocalTemplate = `# .env.local - LOCAL SECRETS FILE (gitignored)
# Auto-generated by drift
#
# Environment: {{.Environment}}
# Git Branch: {{.GitBranch}}
# Supabase Branch: {{.SupabaseBranch}}
# Project Ref: {{.ProjectRef}}
# Using Fallback: {{.IsFallback}}
# Using Override: {{.IsOverride}}
# Generated: {{.GeneratedAt.Format "Mon Jan  2 15:04:05 MST 2006"}}
#
# DO NOT COMMIT THIS FILE

NEXT_PUBLIC_SUPABASE_URL={{.APIURL}}
NEXT_PUBLIC_SUPABASE_ANON_KEY={{.AnonKey}}

# Branch info for environment display
NEXT_PUBLIC_GIT_BRANCH={{.GitBranch}}
NEXT_PUBLIC_SUPABASE_BRANCH={{.SupabaseBranchDisplay}}
NEXT_PUBLIC_DRIFT_ENVIRONMENT={{.Environment}}
`

// Generate generates the .env.local file.
func (g *EnvLocalGenerator) Generate(data EnvLocalData) error {
	tmpl, err := template.New("envlocal").Parse(envLocalTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Ensure directory exists
	dir := filepath.Dir(g.OutputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Create output file
	f, err := os.Create(g.OutputPath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	// Execute template
	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to write .env.local: %w", err)
	}

	return nil
}

// GenerateFromBranchInfo generates .env.local from Supabase branch info.
func (g *EnvLocalGenerator) GenerateFromBranchInfo(info *supabase.BranchInfo, anonKey string) error {
	data := EnvLocalData{
		GitBranch:      info.GitBranch,
		Environment:    string(info.Environment),
		SupabaseBranch: info.SupabaseBranch.Name,
		ProjectRef:     info.ProjectRef,
		APIURL:         info.APIURL,
		AnonKey:        anonKey,
		IsFallback:     info.IsFallback,
		IsOverride:     info.IsOverride,
		GeneratedAt:    time.Now(),
	}

	return g.Generate(data)
}

// ReadEnvLocal reads an existing .env.local file and returns its values as a map.
func ReadEnvLocal(path string) (map[string]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	values := make(map[string]string)
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)

		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse KEY=VALUE
		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			values[key] = value
		}
	}

	return values, nil
}

// GetCurrentEnvironment reads the current environment from the .env.local file.
func GetCurrentEnvironment(envLocalPath string) (string, error) {
	// First try to read from key-value pairs
	values, err := ReadEnvLocal(envLocalPath)
	if err != nil {
		return "", err
	}

	if env, ok := values["NEXT_PUBLIC_DRIFT_ENVIRONMENT"]; ok {
		return env, nil
	}

	// Fallback: try to parse from comment header
	data, err := os.ReadFile(envLocalPath)
	if err != nil {
		return "", err
	}

	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "# Environment:") {
			env := strings.TrimSpace(strings.TrimPrefix(line, "# Environment:"))
			if env != "" {
				return env, nil
			}
		}
	}

	return "", fmt.Errorf("environment not found in %s", envLocalPath)
}

// EnvLocalExists checks if the .env.local file exists.
func EnvLocalExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
