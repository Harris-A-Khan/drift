// Package web provides utilities for web project configuration management.
package web

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/undrift/drift/internal/supabase"
)

// EnvLocalGenerator generates .env.local files for web projects.
type EnvLocalGenerator struct {
	OutputPath string
}

// NewEnvLocalGenerator creates a new .env.local generator.
func NewEnvLocalGenerator(outputPath string) *EnvLocalGenerator {
	return &EnvLocalGenerator{
		OutputPath: outputPath,
	}
}

// EnvLocalData holds the data for .env.local generation.
type EnvLocalData struct {
	GitBranch        string
	Environment      string
	SupabaseBranch   string
	ProjectRef       string
	Region           string
	APIURL           string
	AnonKey          string
	ServiceRoleKey   string
	DatabasePassword string // Optional - from branch secrets or SUPABASE_DB_PASSWORD env var

	// Pre-computed database URLs from branch secrets (if available)
	// These take precedence over computed URLs when set
	DirectDatabaseURL string // From POSTGRES_URL_NON_POOLING in branch secrets
	PoolerDatabaseURL string // From POSTGRES_URL in branch secrets

	IsFallback  bool
	IsOverride  bool
	GeneratedAt time.Time
}

// DatabaseHost returns the direct database host.
func (d EnvLocalData) DatabaseHost() string {
	return fmt.Sprintf("db.%s.supabase.co", d.ProjectRef)
}

// PoolerHost returns the connection pooler host.
func (d EnvLocalData) PoolerHost() string {
	region := d.Region
	if region == "" {
		region = "us-east-1"
	}
	return fmt.Sprintf("aws-0-%s.pooler.supabase.com", region)
}

// DatabaseURL returns the direct database connection URL.
// Uses pre-computed URL from branch secrets if available, otherwise constructs it.
func (d EnvLocalData) DatabaseURL() string {
	// Use pre-computed URL if available
	if d.DirectDatabaseURL != "" {
		return d.DirectDatabaseURL
	}
	// Fall back to constructed URL
	password := d.DatabasePassword
	if password == "" {
		password = "[YOUR-PASSWORD]"
	}
	return fmt.Sprintf("postgresql://postgres:%s@%s:5432/postgres", password, d.DatabaseHost())
}

// PoolerURL returns the pooler connection URL (transaction mode, port 6543).
// Uses pre-computed URL from branch secrets if available, otherwise constructs it.
func (d EnvLocalData) PoolerURL() string {
	// Use pre-computed URL if available
	if d.PoolerDatabaseURL != "" {
		return d.PoolerDatabaseURL
	}
	// Fall back to constructed URL
	password := d.DatabasePassword
	if password == "" {
		password = "[YOUR-PASSWORD]"
	}
	return fmt.Sprintf("postgresql://postgres.%s:%s@%s:6543/postgres", d.ProjectRef, password, d.PoolerHost())
}

// PoolerSessionURL returns the pooler connection URL (session mode, port 5432).
// Derives the host from the pooler URL if available, otherwise constructs it.
func (d EnvLocalData) PoolerSessionURL() string {
	// If we have a pooler URL, extract the host and change port to 5432
	if d.PoolerDatabaseURL != "" {
		// Parse host from postgresql://user:pass@host:port/db
		url := d.PoolerDatabaseURL
		atIdx := strings.Index(url, "@")
		if atIdx != -1 {
			rest := url[atIdx+1:]
			colonIdx := strings.Index(rest, ":")
			if colonIdx != -1 {
				host := rest[:colonIdx]
				password := d.DatabasePassword
				if password == "" {
					password = "[YOUR-PASSWORD]"
				}
				return fmt.Sprintf("postgresql://postgres.%s:%s@%s:5432/postgres", d.ProjectRef, password, host)
			}
		}
	}
	// Fall back to constructed URL
	password := d.DatabasePassword
	if password == "" {
		password = "[YOUR-PASSWORD]"
	}
	return fmt.Sprintf("postgresql://postgres.%s:%s@%s:5432/postgres", d.ProjectRef, password, d.PoolerHost())
}

// HasDatabasePassword returns true if the database password is available.
func (d EnvLocalData) HasDatabasePassword() bool {
	return d.DatabasePassword != ""
}

// SupabaseBranchDisplay returns the branch name with fallback/override suffix.
func (d EnvLocalData) SupabaseBranchDisplay() string {
	if d.IsFallback {
		return d.SupabaseBranch + " (fallback)"
	}
	if d.IsOverride {
		return d.SupabaseBranch + " (override)"
	}
	return d.SupabaseBranch
}

// Section markers for preserving user variables
const (
	DriftSectionStart = "# === DRIFT MANAGED START ==="
	DriftSectionEnd   = "# === DRIFT MANAGED END ==="
)

const envLocalTemplate = `# .env.local - SECRETS FILE (gitignored)
# Auto-generated by drift - DO NOT COMMIT THIS FILE
#
# Environment: {{.Environment}}
# Git Branch: {{.GitBranch}}
# Supabase Branch: {{.SupabaseBranch}}
# Project Ref: {{.ProjectRef}}
# Using Fallback: {{.IsFallback}}
# Using Override: {{.IsOverride}}
# Generated: {{.GeneratedAt.Format "Mon Jan  2 15:04:05 MST 2006"}}

# === DRIFT MANAGED START ===
# Variables below are managed by drift. Do not edit manually.
# Run 'drift env setup' to update these values.

# =============================================================================
# PUBLIC VARIABLES (safe for client-side)
# =============================================================================

# Supabase project URL ({{.SupabaseBranchDisplay}} branch)
NEXT_PUBLIC_SUPABASE_URL={{.APIURL}}

# Supabase anon key (Project Settings > API > anon public)
NEXT_PUBLIC_SUPABASE_ANON_KEY={{.AnonKey}}

# Branch info for environment display
NEXT_PUBLIC_GIT_BRANCH={{.GitBranch}}
NEXT_PUBLIC_SUPABASE_BRANCH={{.SupabaseBranchDisplay}}
NEXT_PUBLIC_DRIFT_ENVIRONMENT={{.Environment}}

# =============================================================================
# SECRET VARIABLES (server-side only - DO NOT prefix with NEXT_PUBLIC_)
# =============================================================================

# Supabase service role key - KEEP SECRET!
SUPABASE_SERVICE_ROLE_KEY={{.ServiceRoleKey}}

# =============================================================================
# DATABASE CONNECTION STRINGS
{{if .HasDatabasePassword}}# Password retrieved from Supabase
{{else}}# Password not available. Set SUPABASE_DB_PASSWORD env var or use non-production branch
{{end}}# =============================================================================

# Direct database connection (for migrations, admin tasks)
DATABASE_URL={{.DatabaseURL}}

# Connection pooler - Transaction mode (port 6543)
DATABASE_URL_POOLER={{.PoolerURL}}

# Connection pooler - Session mode (port 5432)
DATABASE_URL_POOLER_SESSION={{.PoolerSessionURL}}

# === DRIFT MANAGED END ===

# =============================================================================
# CUSTOM VARIABLES (add your own variables below - they will be preserved)
# =============================================================================
`

// Generate generates the .env.local file, preserving user-added variables.
func (g *EnvLocalGenerator) Generate(data EnvLocalData) error {
	tmpl, err := template.New("envlocal").Parse(envLocalTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Generate new drift-managed content
	var driftContent strings.Builder
	if err := tmpl.Execute(&driftContent, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Check if file exists and has user content to preserve
	userContent := ""
	if existingData, err := os.ReadFile(g.OutputPath); err == nil {
		userContent = extractUserContent(string(existingData))
	}

	// Combine drift content with user content
	finalContent := driftContent.String()
	if userContent != "" {
		finalContent = strings.TrimSuffix(finalContent, "\n") + "\n" + userContent
	}

	// Ensure directory exists
	dir := filepath.Dir(g.OutputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write final content
	if err := os.WriteFile(g.OutputPath, []byte(finalContent), 0644); err != nil {
		return fmt.Errorf("failed to write .env.local: %w", err)
	}

	return nil
}

// extractUserContent extracts user-added content from an existing .env.local file.
// It looks for content after the DRIFT MANAGED END marker, or extracts non-drift
// variables from legacy files without markers.
func extractUserContent(content string) string {
	// Check if file has drift markers (new or legacy format)
	endMarkers := []string{
		DriftSectionEnd,
		"# DRIFT SECTION END",
		"# === DRIFT SECTION END ===",
	}

	var afterEnd string
	foundMarker := false
	for _, marker := range endMarkers {
		if idx := strings.Index(content, marker); idx != -1 {
			afterEnd = content[idx+len(marker):]
			foundMarker = true
			break
		}
	}

	if foundMarker {
		// Skip any header lines (=== lines, "NEW VARIABLES" lines, etc.)
		lines := strings.Split(afterEnd, "\n")
		var userLines []string
		inContent := false

		for _, line := range lines {
			trimmed := strings.TrimSpace(line)

			// Skip empty lines and header decorations at the start
			if !inContent {
				if trimmed == "" ||
					strings.HasPrefix(trimmed, "# ===") ||
					strings.Contains(trimmed, "CUSTOM VARIABLES") ||
					strings.Contains(trimmed, "NEW VARIABLES") ||
					strings.Contains(trimmed, "will not be overwritten") ||
					strings.Contains(trimmed, "will be preserved") {
					continue
				}
			}

			// Once we hit actual content, start collecting
			if trimmed != "" && !strings.HasPrefix(trimmed, "# ===") {
				inContent = true
			}

			if inContent {
				userLines = append(userLines, line)
			}
		}

		result := strings.TrimSpace(strings.Join(userLines, "\n"))
		if result != "" {
			return "\n" + result + "\n"
		}
		return ""
	}

	// Legacy file without markers - try to extract non-drift variables
	// Known drift-managed variable prefixes
	driftVars := map[string]bool{
		"NEXT_PUBLIC_SUPABASE_URL":       true,
		"NEXT_PUBLIC_SUPABASE_ANON_KEY":  true,
		"NEXT_PUBLIC_GIT_BRANCH":         true,
		"NEXT_PUBLIC_SUPABASE_BRANCH":    true,
		"NEXT_PUBLIC_DRIFT_ENVIRONMENT":  true,
		"SUPABASE_SERVICE_ROLE_KEY":      true,
		"DATABASE_URL":                   true,
		"DATABASE_URL_POOLER":            true,
		"DATABASE_URL_POOLER_SESSION":    true,
	}

	var userLines []string
	inUserSection := false
	lines := strings.Split(content, "\n")

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip empty lines and comments at the start
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			if inUserSection {
				userLines = append(userLines, line)
			}
			continue
		}

		// Check if this is a variable line
		if strings.Contains(trimmed, "=") {
			parts := strings.SplitN(trimmed, "=", 2)
			varName := strings.TrimSpace(parts[0])

			// Check if this is a drift-managed variable
			if driftVars[varName] {
				continue
			}

			// This is a user variable
			inUserSection = true
			userLines = append(userLines, line)
		} else if inUserSection {
			userLines = append(userLines, line)
		}
	}

	if len(userLines) > 0 {
		result := strings.Join(userLines, "\n")
		result = strings.TrimSpace(result)
		if result != "" {
			return "\n" + result + "\n"
		}
	}

	return ""
}

// BranchSecretsInput holds optional secrets retrieved from branch get command.
type BranchSecretsInput struct {
	AnonKey           string
	ServiceRoleKey    string
	DatabasePassword  string
	DirectDatabaseURL string // POSTGRES_URL_NON_POOLING
	PoolerDatabaseURL string // POSTGRES_URL
}

// GenerateFromBranchInfo generates .env.local from Supabase branch info.
// If secrets is nil, it falls back to SUPABASE_DB_PASSWORD environment variable for password.
func (g *EnvLocalGenerator) GenerateFromBranchInfo(info *supabase.BranchInfo, secrets *BranchSecretsInput) error {
	var anonKey, serviceRoleKey, dbPassword, directURL, poolerURL string

	if secrets != nil {
		anonKey = secrets.AnonKey
		serviceRoleKey = secrets.ServiceRoleKey
		dbPassword = secrets.DatabasePassword
		directURL = secrets.DirectDatabaseURL
		poolerURL = secrets.PoolerDatabaseURL
	}

	// Fall back to environment variable for password
	if dbPassword == "" {
		dbPassword = os.Getenv("SUPABASE_DB_PASSWORD")
	}

	data := EnvLocalData{
		GitBranch:         info.GitBranch,
		Environment:       string(info.Environment),
		SupabaseBranch:    info.SupabaseBranch.Name,
		ProjectRef:        info.ProjectRef,
		Region:            info.Region,
		APIURL:            info.APIURL,
		AnonKey:           anonKey,
		ServiceRoleKey:    serviceRoleKey,
		DatabasePassword:  dbPassword,
		DirectDatabaseURL: directURL,
		PoolerDatabaseURL: poolerURL,
		IsFallback:        info.IsFallback,
		IsOverride:        info.IsOverride,
		GeneratedAt:       time.Now(),
	}

	return g.Generate(data)
}

// ReadEnvLocal reads an existing .env.local file and returns its values as a map.
func ReadEnvLocal(path string) (map[string]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	values := make(map[string]string)
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)

		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse KEY=VALUE
		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			values[key] = value
		}
	}

	return values, nil
}

// GetCurrentEnvironment reads the current environment from the .env.local file.
func GetCurrentEnvironment(envLocalPath string) (string, error) {
	// First try to read from key-value pairs
	values, err := ReadEnvLocal(envLocalPath)
	if err != nil {
		return "", err
	}

	if env, ok := values["NEXT_PUBLIC_DRIFT_ENVIRONMENT"]; ok {
		return env, nil
	}

	// Fallback: try to parse from comment header
	data, err := os.ReadFile(envLocalPath)
	if err != nil {
		return "", err
	}

	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "# Environment:") {
			env := strings.TrimSpace(strings.TrimPrefix(line, "# Environment:"))
			if env != "" {
				return env, nil
			}
		}
	}

	return "", fmt.Errorf("environment not found in %s", envLocalPath)
}

// EnvLocalExists checks if the .env.local file exists.
func EnvLocalExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
